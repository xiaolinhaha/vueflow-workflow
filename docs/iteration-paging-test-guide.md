# 迭代分页功能测试指南

## 功能概述

此功能实现了对 `ForNode`（循环节点）内部子节点的迭代历史记录和分页显示。当循环节点执行时，每次迭代中子节点的执行结果都会被保存，用户可以在右侧面板中通过分页控件查看不同迭代的执行结果。

## 实现的功能

### 1. 后端（Executor）
- ✅ 在 `ExecutionContext` 中添加了迭代历史存储（`nodeIterationHistories`）
- ✅ 在 `WorkflowExecutor` 的 `executeContainerNodes` 方法中，每次迭代后保存子节点的执行结果
- ✅ 添加了 `onIterationUpdate` 回调，实时通知前端新的迭代数据

### 2. 前端（UI）
- ✅ 在 `canvasStore` 中添加了迭代历史管理方法（`appendNodeIterationHistory`, `setNodeIterationPage`, `clearNodeIterationHistory`）
- ✅ 在事件系统中添加了 `execution:iteration:update` 事件
- ✅ 在 `NodeConfigModal` 中实现了分页 UI 和逻辑

### 3. 类型定义
- ✅ `IterationResultData`: 单次迭代的执行数据
- ✅ `IterationHistory`: 迭代历史记录，包含所有迭代的数组和分页信息
- ✅ `NodeExecutionState.iterationHistory`: 节点执行状态中的迭代历史字段

## 测试步骤

### 准备工作
1. 启动开发服务器
2. 打开工作流编辑器

### 测试场景 1：基本循环节点测试

#### 步骤：
1. **创建一个 ForNode（循环节点）**
   - 拖拽一个 `ForNode` 到画布上
   - 配置循环数据源，例如：
     ```json
     {
       "items": [
         {"id": 1, "name": "Item 1"},
         {"id": 2, "name": "Item 2"},
         {"id": 3, "name": "Item 3"}
       ]
     }
     ```
   - 设置迭代变量：`item`

2. **在循环节点内添加子节点**
   - 在 `ForNode` 容器内添加一个 `CodeNode` 或其他处理节点
   - 配置节点使用迭代变量，例如：
     ```javascript
     return {
       processed: `${item.name} - processed`,
       index: item.id
     };
     ```

3. **执行工作流**
   - 点击执行按钮运行整个工作流
   - 观察控制台日志，确认每次迭代都被记录

4. **打开循环内子节点的配置面板**
   - 点击循环内的子节点
   - 查看右侧的输出面板

#### 预期结果：
- ✅ 右侧面板应该显示分页控件（如果有多次迭代）
- ✅ 分页控件显示 "1 / 3"（或实际的迭代次数）
- ✅ 标题后方显示 "迭代 1" 徽章
- ✅ 显示第一次迭代的执行结果

5. **测试分页导航**
   - 点击 "下一页" 按钮（右箭头）
   - 观察页码变化和数据变化

#### 预期结果：
- ✅ 页码从 "1 / 3" 变为 "2 / 3"
- ✅ 徽章显示 "迭代 2"
- ✅ 输出面板显示第二次迭代的执行结果
- ✅ 数据内容与第一次不同（反映第二次迭代的实际数据）

6. **测试边界条件**
   - 在第一页时，"上一页" 按钮应该是禁用状态
   - 在最后一页时，"下一页" 按钮应该是禁用状态
   - 手动跳转到不同页面后，按钮状态应正确更新

### 测试场景 2：嵌套循环测试

#### 步骤：
1. **创建嵌套的 ForNode**
   - 外层 ForNode 迭代 3 次
   - 内层 ForNode 迭代 2 次
   - 在最内层添加一个子节点

2. **执行工作流**
   - 运行工作流
   - 打开最内层子节点的配置面板

#### 预期结果：
- ✅ 应该看到 6 次迭代（3 × 2）
- ✅ 分页控件显示 "1 / 6"
- ✅ 可以浏览所有 6 次迭代的结果

### 测试场景 3：错误处理测试

#### 步骤：
1. **创建会出错的循环**
   - 在循环中添加一个会在第 2 次迭代时出错的节点
   - 例如：访问不存在的属性

2. **执行工作流**
   - 运行工作流，让它在第 2 次迭代时失败

3. **检查迭代历史**
   - 打开子节点配置面板
   - 浏览不同的迭代

#### 预期结果：
- ✅ 第 1 次迭代应显示成功状态和正确的输出
- ✅ 第 2 次迭代应显示错误状态和错误信息
- ✅ 如果有第 3 次迭代，应显示其实际状态

### 测试场景 4：迭代历史清理测试

#### 步骤：
1. **创建并执行循环**
   - 创建一个 ForNode，配置 3 次迭代
   - 在内部添加一个子节点
   - 执行工作流

2. **查看迭代历史**
   - 打开子节点配置面板
   - 确认看到 3 次迭代的历史记录

3. **再次执行同一个工作流**
   - 不刷新页面，直接再次执行工作流
   - 打开子节点配置面板

#### 预期结果：
- ✅ 应该只看到 3 次迭代记录（新执行的）
- ✅ 不应该看到 6 次记录（旧的 + 新的）
- ✅ 控制台应该显示 "清空容器 xxx 内 N 个节点的迭代历史" 日志
- ✅ 前端控制台应该显示 "清空节点 xxx 的旧迭代历史" 日志

### 测试场景 5：性能测试

#### 步骤：
1. **创建大量迭代的循环**
   - 配置 ForNode 迭代 100 次或更多
   - 在内部添加一个简单的子节点

2. **执行工作流**
   - 观察执行时间和浏览器性能

3. **浏览迭代历史**
   - 测试分页的流畅性
   - 快速切换不同的页面

#### 预期结果：
- ✅ 执行过程中不应该有明显的性能问题
- ✅ 分页切换应该快速响应
- ✅ 浏览器内存使用应该在合理范围内

## 验证要点

### UI 检查
- [ ] 分页控件在有迭代历史时显示
- [ ] 分页控件在没有迭代历史时不显示
- [ ] "迭代 N" 徽章正确显示
- [ ] 页码格式 "当前页 / 总页数" 正确
- [ ] 箭头按钮的禁用状态正确
- [ ] 箭头按钮的悬停效果正常

### 功能检查
- [ ] 点击箭头按钮可以切换页面
- [ ] 页面切换时，输出数据正确更新
- [ ] 执行状态（成功/错误/缓存）正确显示
- [ ] 迭代变量信息正确传递
- [ ] 编辑功能在分页模式下正常工作

### 数据完整性检查
- [ ] 每次迭代的数据都被正确保存
- [ ] 迭代索引从 0 开始递增
- [ ] 迭代变量（如 item, index）正确保存
- [ ] 执行时间戳正确记录
- [ ] 执行时长正确计算

### 控制台日志检查
应该看到以下日志：
```
[WorkflowExecutor] 容器 xxx 第 1 次迭代，内有 N 个节点
[WorkflowExecutor] 保存节点 xxx 第 1 次迭代结果: { status: 'success', hasOutput: true }
[CanvasView] 节点 xxx 迭代 1 更新: { iterationIndex: 0, ... }
```

## 已知限制

1. **只对循环容器内的节点有效**
   - 普通节点不会显示迭代历史
   - 只有在 ForNode 等容器内的子节点才会记录迭代历史

2. **迭代历史存储在内存中**
   - 刷新页面后迭代历史会丢失
   - 需要重新执行工作流才能看到迭代历史

3. **大量迭代的性能考虑**
   - 建议对超过 1000 次迭代的情况进行性能优化
   - 可能需要实现虚拟滚动或分批加载

## 故障排查

### 问题：分页控件不显示
**可能原因：**
- 节点不在循环容器内
- 工作流还没有执行
- 迭代历史数据没有正确保存

**检查：**
1. 确认节点确实在 ForNode 容器内
2. 执行工作流并等待完成
3. 检查控制台是否有 "迭代更新" 相关日志
4. 在浏览器开发工具中检查节点的 `data.iterationHistory` 字段

### 问题：页面切换时数据不变化
**可能原因：**
- 迭代历史数据结构不正确
- 页码同步失败

**检查：**
1. 检查 `currentIterationPage` 的值是否正确
2. 检查 `currentIterationData` 计算属性是否返回正确数据
3. 在控制台查看 `iterationHistory.iterations` 数组

### 问题：执行完成后看不到最新迭代
**可能原因：**
- 事件监听没有正确设置
- 数据更新延迟

**检查：**
1. 确认 `execution:iteration:update` 事件被正确触发
2. 检查 `canvasStore.appendNodeIterationHistory` 是否被调用
3. 查看网络面板确认 worker 消息传递正常

## 下一步改进建议

1. **持久化存储**
   - 将迭代历史保存到 localStorage 或后端
   - 支持历史记录的导出和导入

2. **UI 增强**
   - 添加迭代对比功能（并排查看多个迭代）
   - 添加迭代搜索/过滤功能
   - 显示迭代执行时间轴

3. **性能优化**
   - 实现迭代数据的懒加载
   - 大数据集的虚拟滚动
   - 迭代历史的压缩存储

4. **分析功能**
   - 迭代执行时间统计图表
   - 成功率分析
   - 异常迭代高亮显示
